stages: [build, deploy]

variables:
  DOCKER_BUILDKIT: "1"
  IMAGE_TAG: "$CI_COMMIT_SHORT_SHA"
  BRANCH_TAG: "$CI_COMMIT_REF_SLUG-latest"   # 예: main-latest

# -------------------------------
# 공통 Docker 빌드 템플릿
# -------------------------------
.docker-build-template:
  stage: build
  image: docker:24
  services:
    - name: docker:24-dind
      command: ["--mtu=1460"]
  before_script:
    - echo "$CI_JOB_TOKEN" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - docker build -t "$IMAGE_NAME:$IMAGE_TAG" "$BUILD_CONTEXT"
    - docker push "$IMAGE_NAME:$IMAGE_TAG"
    - docker tag  "$IMAGE_NAME:$IMAGE_TAG" "$IMAGE_NAME:$BRANCH_TAG"
    - docker push "$IMAGE_NAME:$BRANCH_TAG"
  rules:
    # 강제 빌드 스위치 (파이프라인 변수로 FORCE_BUILD=true 넣으면 무조건 빌드)
    - if: '$FORCE_BUILD == "true"'
    # 해당 서비스 디렉토리 변경시에만 빌드
    - changes:
      - $BUILD_CONTEXT/** 
      - $BUILD_CONTEXT/Dockerfile
    # 그 외는 스킵
    - when: never

# -------------------------------
# 서비스별 빌드 잡
# -------------------------------
build:order:
  extends: .docker-build-template
  variables:
    IMAGE_NAME: "$CI_REGISTRY_IMAGE/order-service"
    BUILD_CONTEXT: "order-service"

build:inventory:
  extends: .docker-build-template
  variables:
    IMAGE_NAME: "$CI_REGISTRY_IMAGE/inventory-service"
    BUILD_CONTEXT: "inventory-service"

build:fulfillment:
  extends: .docker-build-template
  variables:
    IMAGE_NAME: "$CI_REGISTRY_IMAGE/fulfillment-service"
    BUILD_CONTEXT: "fulfillment-service"

build:api:
  extends: .docker-build-template
  variables:
    IMAGE_NAME: "$CI_REGISTRY_IMAGE/api-gateway"
    BUILD_CONTEXT: "api-gateway"

build:payment-adapter:
  extends: .docker-build-template
  variables:
    IMAGE_NAME: "$CI_REGISTRY_IMAGE/payment-adapter-ext"
    BUILD_CONTEXT: "payment-adapter-ext"


# -------------------------------
# DEPLOY
# -------------------------------
deploy:
  stage: deploy
  image: gcr.io/google.com/cloudsdktool/google-cloud-cli:latest   # Debian 기반 권장
  variables:
    CLOUDSDK_CORE_DISABLE_PROMPTS: "1"
    USE_GKE_GCLOUD_AUTH_PLUGIN: "True"
  # 빌드가 전부 스킵이어도 배포는 항상 진행 (main에서만)
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  before_script:
    # --- kubectl & GKE auth plugin (components install 대신 apt 사용) ---
    - apt-get update
    - apt-get install -y kubectl google-cloud-cli-gke-gcloud-auth-plugin

    # --- SA 키 처리: File/JSON/base64 모두 지원 ---
    - |
      gcloud auth activate-service-account --key-file="$GCP_SA_KEY"
      gcloud config set project "$GCP_PROJECT"

      if [[ "$GKE_LOCATION" == *"-"* ]]; then
        gcloud container clusters get-credentials "$GKE_CLUSTER" --zone "$GKE_LOCATION"
      else
        gcloud container clusters get-credentials "$GKE_CLUSTER" --region "$GKE_LOCATION"
      fi

    # 네임스페이스 보장
    - kubectl get ns "$K8S_NAMESPACE" || kubectl create ns "$K8S_NAMESPACE"

    # --- Helm 설치(이미지 종류 자동 감지) ---
    - |
      if ! command -v helm >/dev/null 2>&1; then
        if [ -f /etc/alpine-release ]; then
          apk add --no-cache openssl curl tar gzip
          export VERIFY_CHECKSUM=true
          curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | sh
        else
          apt-get update
          apt-get install -y ca-certificates curl gnupg openssl tar gzip
          curl -fsSL https://baltocdn.com/helm/signing.asc | gpg --dearmor -o /usr/share/keyrings/helm.gpg
          echo "deb [signed-by=/usr/share/keyrings/helm.gpg] https://baltocdn.com/helm/stable/debian/ all main" > /etc/apt/sources.list.d/helm-stable-debian.list
          apt-get update && apt-get install -y helm
        fi
      fi
    - helm version

    # --- 앱용 Secrets (idempotent)
    - |
      cat <<EOF | kubectl -n "$K8S_NAMESPACE" apply -f -
      apiVersion: v1
      kind: Secret
      metadata: { name: orders-db }
      type: Opaque
      stringData:
        DB_HOST: "${POSTGRES_HOST}"
        DB_PORT: "${POSTGRES_PORT}"
        DB_NAME: "${ORDERS_DB_NAME}"
        DB_USER: "${ORDERS_DB_USER}"
        DB_PASS: "${ORDERS_DB_PASS}"
      ---
      apiVersion: v1
      kind: Secret
      metadata: { name: inventory-db }
      type: Opaque
      stringData:
        DB_HOST: "${POSTGRES_HOST}"
        DB_PORT: "${POSTGRES_PORT}"
        DB_NAME: "${INV_DB_NAME}"
        DB_USER: "${INV_DB_USER}"
        DB_PASS: "${INV_DB_PASS}"
      ---
      apiVersion: v1
      kind: Secret
      metadata: { name: fulfillment-db }
      type: Opaque
      stringData:
        DB_HOST: "${POSTGRES_HOST}"
        DB_PORT: "${POSTGRES_PORT}"
        DB_NAME: "${FUL_DB_NAME}"
        DB_USER: "${FUL_DB_USER}"
        DB_PASS: "${FUL_DB_PASS}"
      EOF

    # Kafka/공통 ENV ConfigMap
    - |
      cat <<EOF | kubectl -n "$K8S_NAMESPACE" apply -f -
      apiVersion: v1
      kind: ConfigMap
      metadata: { name: app-common }
      data:
        KAFKA_BOOTSTRAP_SERVERS: "${KAFKA_BOOTSTRAP}"
        EVENT_NS: "${EVENT_NS}"
        OTEL_EXPORTER_OTLP_ENDPOINT: "${OTEL_EXPORTER_OTLP_ENDPOINT}"
        OTEL_RESOURCE_ENV: "${OTEL_RESOURCE_ENV}"
        PAYMENT_BASE_URL: "http://payment-adapter-ext:9090"
      EOF

    - |
      cat <<EOF | kubectl -n "$K8S_NAMESPACE" apply -f -
      apiVersion: v1
      kind: ConfigMap
      metadata: { name: app-payment }
      data:
        DEFAULT_FAIL_RATE: "${PAYMENT_FAIL_RATE:-0}"
      EOF
    
    # --- values-ci.yaml 생성 (Umbrella 차트에 주입) ---
    - |
      cat > values-ci.yaml <<'YAML'
      global:
        imageRegistry: "${CI_REGISTRY_IMAGE}"
        imageTag: "${BRANCH_TAG}"
        kafkaBootstrap: "${KAFKA_BOOTSTRAP}"

      apps:
        order-service:
          service: { port: 8080 }
          envFromSecrets: [ "orders-db" ]
          envFromConfigMaps: [ "app-common" ]
        inventory-service:
          service: { port: 8080 }
          envFromSecrets: [ "inventory-db" ]
          envFromConfigMaps: [ "app-common" ]
        fulfillment-service:
          service: { port: 8080 }
          envFromSecrets: [ "fulfillment-db" ]
          envFromConfigMaps: [ "app-common" ]
        api-gateway:
          service:
            port: 8080
            type: LoadBalancer   # 필요시 NodePort/ClusterIP로
          envFromConfigMaps: [ "app-common" ]
          env:
            ORDER_SERVICE_URL: "http://order-service:8080"

        payment-adapter-ext:
          service: { port: 9090 }
          envFromConfigMaps: [ "app-payment" ]
      YAML

  script:
    - export IMAGE_TAG="${CI_COMMIT_TAG:-${CI_COMMIT_REF_SLUG:-$CI_COMMIT_SHORT_SHA}}-latest"
    - |
      helm upgrade --install "${HELM_RELEASE_PREFIX}-eda" ./helm/workshop-eda --namespace "$K8S_NAMESPACE" \
      --set global.imageRegistry="$CI_REGISTRY_IMAGE" \
      --set global.imageTag="$IMAGE_TAG" \
      -f values-ci.yaml
    - kubectl -n "$K8S_NAMESPACE" get deploy,svc
    # release marker
    - START_TS=$(date -u +%s%N)
    - echo "$START_TS"
    - echo "$INSTANA_BASE_URL"
    - echo "$CI_COMMIT_SHORT_SHA"
    - |
      curl --location -k --request POST "${INSTANA_BASE_URL}/api/releases" \
        --header "Authorization: apiToken ${INSTANA_API_TOKEN}" \
        --header "Content-Type: application/json" \
        --data "{ \"name\": \"$CI_COMMIT_SHORT_SHA\",\"start\": ${START_TS},\"applications\": [{ \"name\": \"TXC LG Hands-On\" }]}"