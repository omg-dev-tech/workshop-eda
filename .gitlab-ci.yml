stages: [build, deploy]

variables:
  DOCKER_BUILDKIT: "1"
  IMAGE_TAG: "$CI_COMMIT_SHORT_SHA"
  BRANCH_TAG: "$CI_COMMIT_REF_SLUG-latest"   # 예: main-latest

# -------------------------------
# 공통 Docker 빌드 템플릿
# -------------------------------
.docker-build-template:
  stage: build
  image: docker:24
  services:
    - name: docker:24-dind
      command: ["--mtu=1460"]
  before_script:
    - echo "$CI_JOB_TOKEN" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - docker build -t "$IMAGE_NAME:$IMAGE_TAG" "$BUILD_CONTEXT"
    - docker push "$IMAGE_NAME:$IMAGE_TAG"
    - docker tag  "$IMAGE_NAME:$IMAGE_TAG" "$IMAGE_NAME:$BRANCH_TAG"
    - docker push "$IMAGE_NAME:$BRANCH_TAG"
  rules:
    # 강제 빌드 스위치 (파이프라인 변수로 FORCE_BUILD=true 넣으면 무조건 빌드)
    - if: '$FORCE_BUILD == "true"'
    # 해당 서비스 디렉토리 변경시에만 빌드
    - changes:
      - $BUILD_CONTEXT/**/*
    # 그 외는 스킵
    - when: never

# -------------------------------
# 서비스별 빌드 잡
# -------------------------------
build:order:
  extends: .docker-build-template
  variables:
    IMAGE_NAME: "$CI_REGISTRY_IMAGE/order-service"
    BUILD_CONTEXT: "order-service"

build:inventory:
  extends: .docker-build-template
  variables:
    IMAGE_NAME: "$CI_REGISTRY_IMAGE/inventory-service"
    BUILD_CONTEXT: "inventory-service"

build:fulfillment:
  extends: .docker-build-template
  variables:
    IMAGE_NAME: "$CI_REGISTRY_IMAGE/fulfillment-service"
    BUILD_CONTEXT: "fulfillment-service"

build:api:
  extends: .docker-build-template
  variables:
    IMAGE_NAME: "$CI_REGISTRY_IMAGE/api-gateway"
    BUILD_CONTEXT: "api-gateway"

build:payment-adapter:
  extends: .docker-build-template
  variables:
    IMAGE_NAME: "$CI_REGISTRY_IMAGE/payment-adapter-ext"
    BUILD_CONTEXT: "payment-adapter-ext"


# -------------------------------
# DEPLOY
# -------------------------------
deploy:
  stage: deploy
  image: gcr.io/google.com/cloudsdktool/google-cloud-cli:latest   # Debian 기반 권장
  variables:
    CLOUDSDK_CORE_DISABLE_PROMPTS: "1"
    USE_GKE_GCLOUD_AUTH_PLUGIN: "True"
  # 빌드가 전부 스킵이어도 배포는 항상 진행 (main에서만)
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  before_script:
    # --- kubectl & GKE auth plugin (components install 대신 apt 사용) ---
    - apt-get update
    - apt-get install -y kubectl google-cloud-cli-gke-gcloud-auth-plugin

    # --- SA 키 처리: File/JSON/base64 모두 지원 ---
    - |
      gcloud auth activate-service-account --key-file="$GCP_SA_KEY"
      gcloud config set project "$GCP_PROJECT"

      if [[ "$GKE_LOCATION" == *"-"* ]]; then
        gcloud container clusters get-credentials "$GKE_CLUSTER" --zone "$GKE_LOCATION"
      else
        gcloud container clusters get-credentials "$GKE_CLUSTER" --region "$GKE_LOCATION"
      fi

    # 네임스페이스 보장
    - kubectl get ns "$K8S_NAMESPACE" || kubectl create ns "$K8S_NAMESPACE"

    # --- Helm 설치(이미지 종류 자동 감지; APT repo 사용 안 함) ---
    - |
      set -eo pipefail

      # (안전) 혹시 이전 단계에서 남아있을지 모를 Helm APT 소스 제거
      rm -f /etc/apt/sources.list.d/helm-stable-debian.list || true

      if ! command -v helm >/dev/null 2>&1; then
        # 선행 패키지
        if [ -f /etc/alpine-release ]; then
          apk add --no-cache ca-certificates curl tar gzip openssl
        else
          apt-get update
          apt-get install -y ca-certificates curl tar gzip openssl
        fi

        : "${HELM_VERSION:=v3.15.4}"

        OS="$(uname | tr '[:upper:]' '[:lower:]')"
        ARCH="$(uname -m)"
        case "$ARCH" in
          x86_64)  ARCH="amd64" ;;
          aarch64) ARCH="arm64" ;;
          armv7l)  ARCH="arm" ;;
          *) echo "Unsupported arch: $ARCH" >&2; exit 1 ;;
        esac

        TARBALL="helm-${HELM_VERSION}-${OS}-${ARCH}.tar.gz"
        BASEURL="https://get.helm.sh"
        TMPDIR="$(mktemp -d)"
        trap 'rm -rf "$TMPDIR"' EXIT

        echo "→ Download Helm ${HELM_VERSION} ${OS}/${ARCH}"
        curl -fL --retry 5 --retry-connrefused --retry-delay 2 \
          -o "${TMPDIR}/${TARBALL}" "${BASEURL}/${TARBALL}"

        # --- Checksum 다운로드 (여러 후보 경로 시도) ---
        CS_TMP="${TMPDIR}/cs.txt"
        CANDIDATES=(
          "${BASEURL}/${TARBALL}.sha256sum"                # 권장: 아키텍처별
          "${BASEURL}/helm-${HELM_VERSION}-checksums.txt"  # 일부 릴리스에서 제공
          "${BASEURL}/helm-${HELM_VERSION}-sha256sum.txt"  # 일부 릴리스에서 제공(지금 404)
        )

        ok=""
        for url in "${CANDIDATES[@]}"; do
          if curl -fL --retry 5 --retry-connrefused --retry-delay 2 -o "${CS_TMP}" "$url"; then
            ok="$url"; break
          fi
        done

        if [ -z "$ok" ]; then
          echo "⚠️  체크섬 파일을 찾지 못했습니다. (tried: ${CANDIDATES[*]})" >&2
          echo "    계속하려면 검증을 건너뛰거나 내부 미러를 사용하세요."
          exit 1
        fi
        echo "→ Checksum from: $ok"

        # --- Checksum 검증 ---
        if [[ "$ok" == *".tar.gz.sha256sum" ]]; then
          # 파일 하나짜리(.sha256sum) 형식: '<sha256>  <filename>'
          (cd "${TMPDIR}" && sha256sum -c "$(basename "${CS_TMP}")" 2>/dev/null || sha256sum -c "${CS_TMP}")
        else
          # 멀티 엔트리 텍스트인 경우 해당 파일 라인만 골라 검증
          (cd "${TMPDIR}" && grep "  ${TARBALL}\$" "${CS_TMP}" | sha256sum -c -)
        fi

        echo "→ Extract & install"
        tar -xzf "${TMPDIR}/${TARBALL}" -C "${TMPDIR}"

        TARGET_DIR="/usr/local/bin"
        if [ ! -w "$TARGET_DIR" ]; then
          TARGET_DIR="$CI_PROJECT_DIR/bin"
          mkdir -p "$TARGET_DIR"
          # GitLab CI에서 현재 셸 세션 PATH 주입
          echo "export PATH=\"$TARGET_DIR:\$PATH\"" >> "$BASH_ENV" 2>/dev/null || true
          export PATH="$TARGET_DIR:$PATH"
        fi

        install -m 0755 "${TMPDIR}/${OS}-${ARCH}/helm" "${TARGET_DIR}/helm"
      fi

    - helm version

    # --- 앱용 Secrets (idempotent)
    - |
      cat <<EOF | kubectl -n "$K8S_NAMESPACE" apply -f -
      apiVersion: v1
      kind: Secret
      metadata: { name: orders-db }
      type: Opaque
      stringData:
        DB_HOST: "${POSTGRES_HOST}"
        DB_PORT: "${POSTGRES_PORT}"
        DB_NAME: "${ORDERS_DB_NAME}"
        DB_USER: "${ORDERS_DB_USER}"
        DB_PASS: "${ORDERS_DB_PASS}"
      ---
      apiVersion: v1
      kind: Secret
      metadata: { name: inventory-db }
      type: Opaque
      stringData:
        DB_HOST: "${POSTGRES_HOST}"
        DB_PORT: "${POSTGRES_PORT}"
        DB_NAME: "${INV_DB_NAME}"
        DB_USER: "${INV_DB_USER}"
        DB_PASS: "${INV_DB_PASS}"
      ---
      apiVersion: v1
      kind: Secret
      metadata: { name: fulfillment-db }
      type: Opaque
      stringData:
        DB_HOST: "${POSTGRES_HOST}"
        DB_PORT: "${POSTGRES_PORT}"
        DB_NAME: "${FUL_DB_NAME}"
        DB_USER: "${FUL_DB_USER}"
        DB_PASS: "${FUL_DB_PASS}"
      EOF

    # Kafka/공통 ENV ConfigMap
    - |
      cat <<EOF | kubectl -n "$K8S_NAMESPACE" apply -f -
      apiVersion: v1
      kind: ConfigMap
      metadata: { name: app-common }
      data:
        KAFKA_BOOTSTRAP_SERVERS: "${KAFKA_BOOTSTRAP}"
        EVENT_NS: "${EVENT_NS}"
        OTEL_EXPORTER_OTLP_ENDPOINT: "${OTEL_EXPORTER_OTLP_ENDPOINT}"
        OTEL_RESOURCE_ENV: "${OTEL_RESOURCE_ENV}"
        PAYMENT_BASE_URL: "http://payment-adapter-ext:9090"
        PAYMENT_ERROR_MODE: "false"
      EOF

    - |
      cat <<EOF | kubectl -n "$K8S_NAMESPACE" apply -f -
      apiVersion: v1
      kind: ConfigMap
      metadata: { name: app-payment }
      data:
        DEFAULT_FAIL_RATE: "${PAYMENT_FAIL_RATE:-0}"
        PAYMENT_ERROR_MODE: "false"
      EOF
    
    # --- values-ci.yaml 생성 (Umbrella 차트에 주입) ---
    - |
      cat > values-ci.yaml <<'YAML'
      global:
        imageRegistry: "${CI_REGISTRY_IMAGE}"
        imageTag: "${BRANCH_TAG}"
        kafkaBootstrap: "${KAFKA_BOOTSTRAP}"

      apps:
        order-service:
          service: { port: 8080 }
          envFromSecrets: [ "orders-db" ]
          envFromConfigMaps: [ "app-common" ]
        inventory-service:
          service: { port: 8080 }
          envFromSecrets: [ "inventory-db" ]
          envFromConfigMaps: [ "app-common" ]
        fulfillment-service:
          service: { port: 8080 }
          envFromSecrets: [ "fulfillment-db" ]
          envFromConfigMaps: [ "app-common" ]
        api-gateway:
          service:
            port: 8080
            type: LoadBalancer   # 필요시 NodePort/ClusterIP로
          envFromConfigMaps: [ "app-common" ]
          env:
            ORDER_SERVICE_URL: "http://order-service:8080"

        payment-adapter-ext:
          service: { port: 9090 }
          envFromConfigMaps: [ "app-payment" ]
      YAML

  script:
    - export IMAGE_TAG="${CI_COMMIT_TAG:-${CI_COMMIT_REF_SLUG:-$CI_COMMIT_SHORT_SHA}}-latest"
    - |
      helm upgrade --install "${HELM_RELEASE_PREFIX}-eda" ./helm/workshop-eda --namespace "$K8S_NAMESPACE" \
      --set global.imageRegistry="$CI_REGISTRY_IMAGE" \
      --set global.imageTag="$IMAGE_TAG" \
      -f values-ci.yaml
    - kubectl -n "$K8S_NAMESPACE" get deploy,svc
    # release marker
    - START_TS=$(date -u +%s%3N)
    - echo "$START_TS"
    - echo "$INSTANA_BASE_URL"
    - echo "$CI_COMMIT_SHORT_SHA"
    - |
      curl --location -k --request POST "${INSTANA_BASE_URL}/api/releases" \
        --header "Authorization: apiToken ${INSTANA_API_TOKEN}" \
        --header "Content-Type: application/json" \
        --data "{ \"name\": \"$CI_COMMIT_SHORT_SHA\",\"start\": ${START_TS},\"applications\": [{ \"name\": \"TXC LG Hands-On\" }]}"
    - kubectl -n "$K8S_NAMESPACE" rollout restart deploy payment-adapter-ext